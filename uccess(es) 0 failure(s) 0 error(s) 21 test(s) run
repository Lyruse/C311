[1mdiff --git a/a3.rkt b/a3.rkt[m
[1mindex 37e2fdb..3eda34e 100644[m
[1m--- a/a3.rkt[m
[1m+++ b/a3.rkt[m
[36m@@ -171,6 +171,8 @@[m
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;[m
 [m
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  interpretert 1 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;[m
[32m+[m[32m;; First Edition[m
[32m+[m[32m;; Date: 2014-12-29 4:00am.[m
 (define value-of[m
   (lambda (exp env)[m
     (pmatch exp[m
[36m@@ -209,7 +211,7 @@[m
            (value-of alt env))][m
       [`(set! ,var ,value)[m
        `((,var . ,value) . ())][m
[31m-      [`(begin2 ,e1 ,e2)     [m
[32m+[m[32m      [`(begin2 ,e1 ,e2)     ;;;;;;;;;;;;;;;;;;;;;; It's time to include closures, which makes lambda work.[m
        (let ([res (value-of e1 (lambda (id)[m
                                  (if (eq? 'inside id)[m
                                      #t[m
[36m@@ -344,4 +346,82 @@[m
                 (f) adbmal)[m
                ((((((n 1bus) (f f)) n *) 1 (n ?orez) fi)[m
                  (n) adbmal)[m
[31m-                (f) adbmal))) (empty-env))  ;; ==> 120[m
\ No newline at end of file[m
[32m+[m[32m                (f) adbmal))) (empty-env))  ;; ==> 120[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  Assignment 7 ;;;;;;;;;;;;;;;;;;;;[m
[32m+[m[32m; define value-of-lex:[m
[32m+[m[32m(define value-of-lex[m
[32m+[m[32m  (lambda(exp env)[m
[32m+[m[32m    (pmatch exp[m
[32m+[m[32m      (`,c (guard (or (boolean? c) (number? c))) c)[m[41m [m
[32m+[m[32m      (`(sub1 ,body) (sub1 (value-of-lex body env)))[m
[32m+[m[32m      (`(zero? ,body) (zero? (value-of-lex body env)))[m
[32m+[m[32m      (`(* ,n1 ,n2) (* (value-of-lex n1 env) (value-of-lex n2 env)))[m
[32m+[m[32m      (`(if ,t ,c ,a) (if (value-of-lex t env) (value-of-lex c env) (value-of-lex a env)))[m
[32m+[m[32m      (`(var ,num) (apply-env-lex env num))[m
[32m+[m[32m      (`(lambda ,body) (lambda (a) (value-of-lex body (extend-env-lex a env))))[m
[32m+[m[32m      (`(,rator ,rand) ((value-of-lex rator env) (value-of-lex rand env))))))[m
[32m+[m[41m [m
[32m+[m[32m(define empty-env-lex[m[41m [m
[32m+[m[32m  (lambda () '()))[m
[32m+[m[32m(define extend-env-lex[m
[32m+[m[32m  (lambda (val env)[m
[32m+[m[32m    (cons val env)))[m
[32m+[m[32m(define apply-env-lex[m
[32m+[m[32m  (lambda (env n)[m
[32m+[m[32m    (cond[m
[32m+[m[32m    #;  [(null? env) (error 'env "unbound variable. ~s" n)] ; not neccesary[m
[32m+[m[32m    ;; not required to handle bad data.[m
[32m+[m[32m      [(zero? n) (car env)][m[41m       [m
[32m+[m[32m      [else (apply-env-lex (cdr env) (- n 1))])))[m
[32m+[m
[32m+[m[32m;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Church numerals ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;[m
[32m+[m[32m(define c0 (lambda (f) (lambda (x) x)))[m
[32m+[m[32m(define c5 (lambda (f) (lambda (x) (f (f (f (f (f x))))))))[m
[32m+[m[32m(define c1 (lambda (f) (lambda (b) (f b))))[m
[32m+[m[32m;=> ((c5 add1) 0)   ;; numbers are those defined by their interface procedure.[m
[32m+[m[32m(define c+ (lambda (m)[m
[32m+[m[32m             (lambda (n)[m
[32m+[m[32m               (lambda (f)[m
[32m+[m[32m                 (lambda (base)[m
[32m+[m[32m                   ((m f) ((n f) base)))))))[m
[32m+[m[32m#;  (let ((c10 ((c+ c5) c5))))[m
[32m+[m[32m; => ((c10 add1) 0))[m
[32m+[m[41m      [m
[32m+[m[41m      [m
[32m+[m[32m;;            Church predecessor[m
[32m+[m[32m#; (((csub1 c5) add1) 0)[m
[32m+[m[32m; => 4[m
[32m+[m[32m#;  (((csub1 c0) add1) 0) ; => 0[m
[32m+[m[32m(define csub1[m
[32m+[m[32m  (lambda (n)[m
[32m+[m[32m    (lambda (f)[m
[32m+[m[32m      (lambda (base)[m
[32m+[m[32m        (((n (lambda (g) (lambda (h) (h (g f)))))[m[41m [m
[32m+[m[32m          (lambda (u) base))[m[41m [m
[32m+[m[32m         (lambda (id) id))))))[m
[32m+[m[32m;[m
[32m+[m[32m;(((c1 (lambda (g) (lambda (h) (h (g f)))))[m[41m [m
[32m+[m[32m;  (lambda (u) base))[m[41m [m
[32m+[m[32m; (lambda (id) id))[m
[32m+[m[32m;;=>[m
[32m+[m[32m;(((lambda (g) (lambda (h) (h (g f)))) (lambda (u) base))[m
[32m+[m[32m; (lambda (id) id))[m
[32m+[m[32m;(((c2 (lambda (g) (lambda (h) (h (g f)))))[m[41m [m
[32m+[m[32m;  (lambda (u) base))[m[41m [m
[32m+[m[32m; (lambda (id) id))[m
[32m+[m[32m;(f (f x))[m
[32m+[m[32m;((lambda (g) (lambda (h) (h (g f))))[m
[32m+[m[32m; ((lambda (g) (lambda (h) (h (g f))))[m
[32m+[m[32m;  ((lambda (g) (lambda (h) (h (g f)))) ; looks a little like cps style[m
[32m+[m[32m;   (lambda (u) base))))[m
\ No newline at end of file[m
[1mdiff --git a/a4.rkt b/a4.rkt[m
[1mnew file mode 100644[m
[1mindex 0000000..37a8fac[m
[1m--- /dev/null[m
[1m+++ b/a4.rkt[m
[36m@@ -0,0 +1,230 @@[m
[32m+[m[32m; Assignment 4: Dynamic Scope[m
[32m+[m
[32m+[m[32m; Author: Lyruse Huang.[m
[32m+[m[32m; Date: 2014-12-29.[m
[32m+[m[32m; Assignments from C311 which is Daniel Friedman's class in 2014[m
[32m+[m[32m; Webpage for these assignments:[m[41m [m
[32m+[m[32m; https://cgi.soic.indiana.edu/~c311/doku.php?id=assignment-4[m
[32m+[m
[32m+[m[32m#lang racket[m
[32m+[m[32m(require C311/pmatch)[m
[32m+[m[32m#;(require C311/a4-student-tests)[m
[32m+[m[32m#;(test-file)[m
[32m+[m[32m;; test result:[m[41m [m
[32m+[m[32m;; 21 success(es) 0 failure(s) 0 error(s) 21 test(s) run.  Perfect![m
[32m+[m
[32m+[m[32m;;;;;;;;;;;;;;;;;;;;;;; association list as environment ;;;;;;;;;;;;;;;;;;;;;;;;;;[m
[32m+[m[32m(define empty-env[m
[32m+[m[32m  (lambda ()[m
[32m+[m[32m    '()))[m
[32m+[m[32m(define extend-env[m
[32m+[m[32m  (lambda (var val env)[m
[32m+[m[32m    `((,var . ,val) . ,env)))[m
[32m+[m[32m(define apply-env[m
[32m+[m[32m  (lambda (env var)[m
[32m+[m[32m    (cond[m
[32m+[m[32m      [(assq var env) => cdr][m
[32m+[m[32m      [else (error 'env "unbound variable. ~s" var)])))[m
[32m+[m[32m;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;[m
[32m+[m
[32m+[m[32m;;;;;;;;;;;;;;;;;;;;;;;; closure representation using higher-order functions ;;;;;;;;;;;;;;[m
[32m+[m[32m(define closure-fn[m
[32m+[m[32m  (lambda (x body env)[m
[32m+[m[32m    (lambda (arg)[m
[32m+[m[32m         (value-of-fn body (extend-env x arg env)))))[m
[32m+[m[32m(define apply-closure-fn[m
[32m+[m[32m  (lambda (clo arg)[m
[32m+[m[32m    (clo arg)))[m
[32m+[m[32m;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;[m
[32m+[m
[32m+[m[32m;;;;;;;;;;;;;;;;;;;;;;;;closure representation using data-structure;;;;;;;;;;;;;;;[m
[32m+[m[32m(define closure-ds[m
[32m+[m[32m  (lambda (x body env)[m
[32m+[m[32m    `(closure ,x ,body ,env)))[m
[32m+[m[32m(define apply-closure-ds[m
[32m+[m[32m  (lambda (closure arg)[m
[32m+[m[32m    (pmatch closure[m
[32m+[m[32m      [`(closure ,x ,body ,env)[m
[32m+[m[32m       (value-of-ds body (extend-env x arg env))])))[m
[32m+[m[32m;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;[m
[32m+[m
[32m+[m
[32m+[m[32m;;;;;;;;;;;;;;;;;;;;;     interpreter 1    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;[m
[32m+[m[32m(define value-of-fn[m
[32m+[m[32m  (lambda (exp env)[m
[32m+[m[32m    (pmatch exp[m
[32m+[m[32m      [`,x (guard (number? x)) x][m
[32m+[m[32m      [`,x (guard (symbol? x)) (apply-env env x)][m
[32m+[m[32m      [`,x (guard (boolean? x)) x][m
[32m+[m[32m      [`(lambda (,x) ,body)[m
[32m+[m[32m       (closure-fn x body env)][m
[32m+[m[32m      [`(zero? ,op)[m
[32m+[m[32m       (zero? (value-of-fn op env))][m
[32m+[m[32m      [`(sub1 ,op)[m
[32m+[m[32m       (sub1 (value-of-fn op env))][m
[32m+[m[32m      [`(* ,op1 ,op2)[m
[32m+[m[32m       (* (value-of-fn op1 env)[m
[32m+[m[32m          (value-of-fn op2 env))][m
[32m+[m[32m      [`(let ([,var ,exp])[m
[32m+[m[32m          ,body)[m
[32m+[m[32m       (value-of-fn body (extend-env[m[41m [m
[32m+[m[32m                          var[m[41m [m
[32m+[m[32m                          (value-of-fn exp env) env))][m
[32m+[m[32m      [`(if ,test ,conseq ,alt)[m
[32m+[m[32m       (if (value-of-fn test env)[m
[32m+[m[32m           (value-of-fn conseq env)[m
[32m+[m[32m           (value-of-fn alt env))][m
[32m+[m[32m      [`(,rator ,rand)[m
[32m+[m[32m       (apply-closure-fn[m
[32m+[m[32m        (value-of-fn rator env)[m
[32m+[m[32m        (value-of-fn rand env))])))[m
[32m+[m
[32m+[m
[32m+[m[32m;;;;;;;;;;;;;;;;;;;;;;;;;     interpreter 2     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;[m
[32m+[m[32m(define value-of-ds[m
[32m+[m[32m  (lambda (exp env)[m
[32m+[m[32m    (pmatch exp[m
[32m+[m[32m      [`,x (guard (number? x)) x][m
[32m+[m[32m      [`,x (guard (symbol? x)) (apply-env env x)][m
[32m+[m[32m      [`,x (guard (boolean? x)) x][m
[32m+[m[32m      [`(lambda (,x) ,body)[m
[32m+[m[32m       (closure-ds x body env)][m
[32m+[m[32m      [`(zero? ,op)[m
[32m+[m[32m       (zero? (value-of-ds op env))][m
[32m+[m[32m      [`(sub1 ,op)[m
[32m+[m[32m       (sub1 (value-of-ds op env))][m
[32m+[m[32m      [`(* ,op1 ,op2)[m
[32m+[m[32m       (* (value-of-ds op1 env)[m
[32m+[m[32m          (value-of-ds op2 env))][m
[32m+[m[32m      [`(let ([,var ,exp])[m
[32m+[m[32m          ,body)[m
[32m+[m[32m       (value-of-ds body (extend-env[m[41m [m
[32m+[m[32m                          var[m[41m [m
[32m+[m[32m                          (value-of-ds exp env) env))][m
[32m+[m[32m      [`(if ,test ,conseq ,alt)[m
[32m+[m[32m       (if (value-of-ds test env)[m
[32m+[m[32m           (value-of-ds conseq env)[m
[32m+[m[32m           (value-of-ds alt env))][m
[32m+[m[32m      [`(,rator ,rand)[m
[32m+[m[32m       (apply-closure-ds[m
[32m+[m[32m        (value-of-ds rator env)[m
[32m+[m[32m        (value-of-ds rand env))])))[m
[32m+[m
[32m+[m
[32m+[m[32m;;;;;;;;;;;;;;;;;;;;;;;;;; interpreter 3  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;[m
[32m+[m[32m;;The interpreters we have been writing so far have been implemented[m[41m [m
[32m+[m[32m;;in such a way that, if there are variables that occur free in a procedure,[m
[32m+[m[32m;;they take their values from the environment in which the lambda expression[m[41m [m
[32m+[m[32m;;is defined. We accomplish this by creating a closure for each procedure[m[41m [m
[32m+[m[32m;;we see, and we save the environment in the closure. This technique is[m[41m [m
[32m+[m[32m;;called static binding of variables, or static scope.[m
[32m+[m[32m;;Lexical scope is a kind of static scope.[m
[32m+[m
[32m+[m[32m;;Alternatively, we could implement our interpreters such that[m[41m [m
[32m+[m[32m;;any variables that occur free in the body of a procedure get their values[m
[32m+[m[32m;;from the environment from which the procedure is called,[m[41m [m
[32m+[m[32m;;rather than from the environment in which the procedure is defined.[m
[32m+[m
[32m+[m[32m(define closure-scopes[m
[32m+[m[32m  (case-lambda[m[41m [m
[32m+[m[32m    [(x body env)[m
[32m+[m[32m     `(closure ,x ,body ,env)][m
[32m+[m[32m    [(x body)[m
[32m+[m[32m     `(closure ,x ,body)]))[m
[32m+[m[32m(define apply-closure-scopes[m
[32m+[m[32m  (case-lambda[m[41m [m
[32m+[m[32m    [(closure arg newenv)[m
[32m+[m[32m     (pmatch closure[m
[32m+[m[32m       [`(closure ,x ,body ,env)[m
[32m+[m[32m        (value-of-scopes body (extend-env x arg env))][m
[32m+[m[32m       [`(closure ,x ,body)[m
[32m+[m[32m        (value-of-scopes body (extend-env x arg newenv))])]))[m
[32m+[m
[32m+[m[32m(define value-of-scopes[m
[32m+[m[32m  (lambda (exp env)[m
[32m+[m[32m    (pmatch exp[m
[32m+[m[32m      [`,n (guard (number? n)) n][m
[32m+[m[32m      [`,x (guard (symbol? x)) (apply-env env x)][m
[32m+[m[32m      [`(quote ()) '()][m
[32m+[m[32m      [`(null? ,ls)[m[41m [m
[32m+[m[32m       (equal? (value-of-scopes ls env) '())][m
[32m+[m[32m      [`(cons ,a ,d)[m[41m [m
[32m+[m[32m       (cons (value-of-scopes a env) (value-of-scopes d env))][m
[32m+[m[32m      [`(car ,ls)[m[41m [m
[32m+[m[32m       (car (value-of-scopes ls env))][m
[32m+[m[32m      [`(cdr ,ls)[m
[32m+[m[32m       (cdr (value-of-scopes ls env))][m
[32m+[m[32m      [`(* ,nexp1 ,nexp2)[m[41m [m
[32m+[m[32m       (* (value-of-scopes nexp1 env)[m[41m [m
[32m+[m[32m          (value-of-scopes nexp2 env))][m
[32m+[m[32m      [`(sub1 ,nexp)[m[41m [m
[32m+[m[32m       (sub1 (value-of-scopes nexp env))][m
[32m+[m[32m      [`(if ,t ,c ,a)[m[41m [m
[32m+[m[32m       (if (value-of-scopes t env)[m
[32m+[m[32m           (value-of-scopes c env)[m
[32m+[m[32m           (value-of-scopes a env))][m
[32m+[m[32m      [`(let ((,x ,e)) ,body)[m
[32m+[m[32m       (let ((a (value-of-scopes e env)))[m
[32m+[m[32m         (value-of-scopes body (extend-env x a env)))][m
[32m+[m[32m      [`(lambda (,x) ,body)[m[41m [m
[32m+[m[32m       (closure-scopes x body env)][m
[32m+[m[32m      [`(d-lambda (,x) ,body)[m
[32m+[m[32m       (closure-scopes x body)][m
[32m+[m[32m      [`(,rator ,rand)[m[41m [m
[32m+[m[32m       (apply-closure-scopes[m
[32m+[m[32m        (value-of-scopes rator env)[m
[32m+[m[32m        (value-of-scopes rand env)[m
[32m+[m[32m        env)])))[m
[32m+[m
[32m+[m[32m;;;;;;;;;;;;;;;;;;;;;       interpreter 4     ;;;;;;;;;;;;;;;;;;;;;;;;;;[m
[32m+[m[32m(define empty-env-fn empty-env)[m
[32m+[m[32m(define empty-env-ds empty-env)[m
[32m+[m[32m(define extend-env-fn extend-env)[m
[32m+[m[32m(define extend-env-ds extend-env)[m
[32m+[m[32m(define apply-env-fn apply-env)[m
[32m+[m[32m(define apply-env-ds apply-env)[m
[32m+[m
[32m+[m[32m(define closure-fn-ri[m
[32m+[m[32m  (lambda (x body env f)   ;; add one more parameter to deal with the body.[m
[32m+[m[32m    (lambda (arg ext)[m
[32m+[m[32m      ((f (ext x arg env)) body))))[m
[32m+[m[32m(define apply-closure-fn-ri[m
[32m+[m[32m  (lambda (clos arg extend-env) ;; cooperate with closure-fn-ri, add one more parameter.[m
[32m+[m[32m    (clos arg extend-env)))[m
[32m+[m[32m(define closure-ds-ri closure-fn-ri)[m
[32m+[m[32m(define apply-closure-ds-ri apply-closure-fn-ri)[m
[32m+[m
[32m+[m[32m(define value-of-ri[m
[32m+[m[32m  (lambda (empty-env extend-env apply-env closure apply-closure)[m
[32m+[m[32m    (letrec ([loop (lambda (env)[m
[32m+[m[32m                     (lambda (exp)[m
[32m+[m[32m                       (pmatch exp[m
[32m+[m[32m                         [`,n (guard (number? n)) n][m
[32m+[m[32m                         [`,b (guard (boolean? b)) b][m
[32m+[m[32m                         [`,x (guard (symbol? x)) (apply-env env x)][m
[32m+[m[32m                         [`(* ,op1 ,op2)[m
[32m+[m[32m                          (* ((loop env) op1)[m[41m [m
[32m+[m[32m                             ((loop env) op2))][m
[32m+[m[32m                         [`(sub1 ,op)[m
[32m+[m[32m                          ((loop env) op)][m
[32m+[m[32m                         [`(zero? ,op)[m
[32m+[m[32m                          (zero? ((loop env) op))][m
[32m+[m[32m                         [`(if ,t ,c ,a)[m
[32m+[m[32m                          (if ((loop env) t)[m
[32m+[m[32m                              ((loop env) c)[m
[32m+[m[32m                              ((loop env) a))][m
[32m+[m[32m                         [`(let ([,x ,e])[m
[32m+[m[32m                             ,body)[m
[32m+[m[32m                          (let ([val ((loop env) e)])[m
[32m+[m[32m                            ((loop (extend-env x val)) body))][m
[32m+[m[32m                         [`(lambda (,x) ,body)[m
[32m+[m[32m                          (closure x body env loop)][m
[32m+[m[32m                         [`(,rator ,rand)[m
[32m+[m[32m                          (apply-closure[m[41m [m
[32m+[m[32m                           ((loop env) rator)[m
[32m+[m[32m                           ((loop env) rand)[m
[32m+[m[32m                           extend-env)])))])[m
[32m+[m[32m      (loop (empty-env)))))[m
[32m+[m[32m;((value-of-ri empty-env-fn extend-env-fn apply-env-fn closure-fn-ri apply-closure-fn-ri)[m[41m [m
[32m+[m[32m; '((lambda (x) x) 5))[m
[32m+[m[32m;=> 5[m
\ No newline at end of file[m
warning: LF will be replaced by CRLF in a3.rkt.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in a4.rkt.
The file will have its original line endings in your working directory.
